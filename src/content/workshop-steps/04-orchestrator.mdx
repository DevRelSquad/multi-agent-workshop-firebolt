---
title: "Orchestrator Agent"
description: "Build an orchestrator agent that coordinates multiple agents"
duration: "45 minutes"
difficulty: "Intermediate"
objectives:
  - "Implement intent parsing with Gemini"
  - "Build multi-step query orchestration"
  - "Route tasks to appropriate agents"
---

import { CodeBlock } from '@/components/workshop/CodeBlock';
import { Exercise } from '@/components/workshop/Exercise';
import { Hint } from '@/components/workshop/Hint';
import { Checkpoint } from '@/components/workshop/Checkpoint';
import { TestButton } from '@/components/workshop/TestButton';

## Overview

The **Orchestrator Agent** is the brain of your multi-agent system. It uses Gemini AI to understand user intent and coordinates multiple agents (Analytics, Report) to fulfill complex requests. In this tutorial, you'll build:

1. **Intent parsing** - Use Gemini to classify user queries
2. **Multi-step orchestration** - Chain analytics â†’ report â†’ email workflows
3. **Task routing** - Direct queries to the appropriate agent

## Key Concepts

### Orchestrator Workflow
```
User Query â†’ Parse Intent â†’ Route to Agent(s) â†’ Execute â†’ Return Results
```

### Intent Classification
The orchestrator classifies queries into:
- `analytics` - Data queries (revenue, products, user behavior)
- `report` - Report generation requests
- `email` - Email delivery requests
- `multi_step` - Combined workflows (analytics + report + email)

### Agent Coordination
The orchestrator manages three agents:
- **AnalyticsAgent** - Already implemented âœ…
- **ReportAgent** - Partially implemented (generateReport needs completion)
- **OrchestratorAgent** - This is what you'll build!

## Implement Intent Parsing

The `parseIntent` method is **already implemented** in `src/lib/agents/orchestrator.ts`. It uses Gemini AI to classify user queries.

**What it does:**
- Uses Gemini 2.5 Flash to analyze user queries
- Returns intent classification: `analytics`, `report`, `email`, or `multi_step`
- Extracts entities: query_type, time_range, recipient
- Includes confidence score (0.0 to 1.0)

**Example:**
```typescript
const intent = await orchestrator.parseIntent("Show me revenue and email to john@example.com");
// Returns: { intent: 'multi_step', entities: { query_type: 'revenue', recipient: 'john@example.com' }, confidence: 0.95 }
```

---

##Complete the Analytics Agent executeQuery(TODO)

**ğŸ“ File:** `src/lib/agents/analytics.ts`

Look for the `TODO: Exercise 1` comment. The query building logic exists, but you need to implement the execution logic.

<Exercise title="Implement executeQuery execution logic">

The `buildQueries` function already creates all SQL queries. You need to:
1. Validate that `queryType` exists in the queries object
2. Throw an error if the query type is unknown
3. Execute the query using `this.mcpClient.execute()`
4. Return the result



**Requirements:**
- Check if `queries[queryType]` exists
- If not, throw error: `Unknown query type: ${queryType}`
- Execute: `await this.mcpClient.execute(queries[queryType])`
- Return the result

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`async executeQuery(queryType: string): Promise<QueryResult> {
  const queries = buildQueries(this.tableName);
  
  if (!queries[queryType]) {
    throw new Error(\`Unknown query type: \${queryType}\`);
  }

  return await this.mcpClient.execute(queries[queryType]);
}`} />
</Hint>

</Exercise>

---

## Complete the Report Agent generateReport

**ğŸ“ File:** `src/lib/agents/report.ts`

Look for the `TASK 1` comment. The prompt builder is already implemented in `reportPrompts.ts`, but you need to connect it to Gemini.

<Exercise title="Implement generateReport method">



**Requirements:**
1. Use `this.model.generateContent(prompt)` to call Gemini
2. Extract the text from the result using `result.response.text()`
3. Return the generated report text

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`async generateReport(data: any, reportType: 'summary' | 'detailed' = 'summary'): Promise<string> {
  const prompt = buildSummaryPrompt(data, reportType);

  const result = await this.model.generateContent(prompt);
  return result.response.text();
}`} />
</Hint>

</Exercise>

---

## Implement Multi-Step Query Orchestration

**ğŸ“ File:** `src/lib/agents/orchestrator.ts`

Look for the `TODO: Exercise 3` comment in the `handleMultiStepQuery` method.

<Exercise title="Complete the multi-step orchestration">

The method already has the workflow structure in place. You need to add the intent parsing at the beginning.

**Current code:**
```typescript
async handleMultiStepQuery(userQuery: string) {
  const steps: any[] = [];
  
  try {
    // TODO: Exercise 3 - Parse the user query to extract intent and entities (2-3 lines)
    // HINT: Use this.parseIntent(userQuery) and extract queryType and recipient from entities
    const intent = null; // Replace with parseIntent call
    const queryType = null; // Extract from intent.entities.query_type
    const recipient = null; // Extract from intent.entities.recipient
    
    // ... rest of the orchestration logic
  }
}
```

**Requirements:**
1. Call `this.parseIntent(userQuery)` and store the result in `intent`
2. Extract `queryType` from `intent.entities.query_type`
3. Extract `recipient` from `intent.entities.recipient`

**Example workflow:**
- User asks: "Show me revenue and email to john@example.com"
- Intent parsed: `{ intent: 'multi_step', entities: { query_type: 'revenue', recipient: 'john@example.com' }}`
- Steps executed:
  1. Analytics query (revenue)
  2. Report generation
  3. Email delivery

<Hint title="Full implementation (click to reveal)">
<CodeBlock language="typescript" code={`// TODO: Exercise 3 - Parse the user query to extract intent and entities (2-3 lines)
const intent = await this.parseIntent(userQuery);
const queryType = intent.entities.query_type;
const recipient = intent.entities.recipient;`} />
</Hint>

</Exercise>

---

## Checkpoint

<Checkpoint items={[
  "parseIntent method works correctly (already implemented âœ…)",
  "AnalyticsAgent executeQuery validates query types and executes queries",
  "ReportAgent generateReport calls Gemini and returns formatted reports",
  "OrchestratorAgent handleMultiStepQuery parses intent and orchestrates workflow",
  "Multi-step queries chain analytics â†’ report â†’ email successfully",
  "Error handling returns appropriate status codes and messages"
]} />

---

## Orchestration Architecture

The orchestrator uses a **sequential workflow**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Query     â”‚
â”‚  "Show revenue  â”‚
â”‚  and email it"  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ parseIntent()   â”‚  â† Uses Gemini AI
â”‚ Intent: multi_  â”‚
â”‚ step            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1:         â”‚
â”‚ Analytics Query â”‚  â† AnalyticsAgent
â”‚ (revenue)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2:         â”‚
â”‚ Generate Report â”‚  â† ReportAgent
â”‚ (from data)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3:         â”‚
â”‚ Send Email      â”‚  â† ReportAgent.sendEmail()
â”‚ (to recipient)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Test Your Orchestrator

<TestButton label="Test Orchestrator" message="Use the Orchestrator Demo to test multi-step workflows!" />

**Test scenarios:**
1. âœ… **Simple analytics**: "Show me revenue" â†’ Should execute analytics query only
2. âœ… **Report generation**: "Generate a revenue report" â†’ Should run analytics + report
3. âœ… **Email delivery**: "Show top products and email to test@example.com" â†’ Should run analytics + report + email
4. âœ… **Natural language**: "What are my best selling products?" â†’ Should parse intent and execute

**Expected workflow for "Show revenue and email to john@example.com":**
```json
{
  "success": true,
  "totalSteps": 3,
  "steps": [
    {
      "step": "analytics",
      "action": "revenue_query",
      "status": "completed",
      "output": { /* revenue data */ }
    },
    {
      "step": "report",
      "action": "generate_financial_report",
      "status": "completed",
      "output": "# Revenue Analysis Report..."
    },
    {
      "step": "email",
      "action": "send_report",
      "status": "completed",
      "output": {
        "recipient": "john@example.com",
        "subject": "Revenue Analysis Report",
        "sent": true,
        "sandbox": true
      }
    }
  ]
}
```

---

## Advanced: Extend the Orchestrator

Want to add more capabilities? Try these:

### 1. Add Retry Logic
```typescript
async executeWithRetry(fn: () => Promise<any>, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
    }
  }
}
```

### 2. Add Parallel Execution
For independent tasks that don't depend on each other:
```typescript
async handleParallelQuery(queries: string[]) {
  const analytics = new AnalyticsAgent();
  const results = await Promise.all(
    queries.map(q => analytics.executeQuery(q))
  );
  return results;
}
```

### 3. Add Caching
Cache frequently requested reports:
```typescript
private cache = new Map<string, { data: any, timestamp: number }>();

async getCachedReport(queryType: string, ttl = 300000) { // 5 min TTL
  const cached = this.cache.get(queryType);
  if (cached && Date.now() - cached.timestamp < ttl) {
    return cached.data;
  }
  
  const data = await this.executeQuery(queryType);
  this.cache.set(queryType, { data, timestamp: Date.now() });
  return data;
}
```

### 4. Add Task Routing (Already Implemented âœ…)
The `routeTask` method is already implemented:
```typescript
routeTask(intent: IntentResult): AgentType {
  if (intent.intent === 'analytics') return 'analytics';
  if (intent.intent === 'report') return 'report';
  if (intent.intent === 'email') return 'email';
  return 'unknown';
}
```

---

## Summary

You've built a complete **Orchestrator Agent** that:
- âœ… Parses user intent with Gemini AI (already implemented)
- âœ… Coordinates multiple agents (Analytics, Report)
- âœ… Executes multi-step workflows (analytics â†’ report â†’ email)
- âœ… Handles errors gracefully
- âœ… Routes tasks to appropriate agents

### Key Takeaways:
1. **Intent parsing** is critical for understanding user requests
2. **Sequential orchestration** ensures proper data flow between agents
3. **Error handling** at each step prevents cascade failures
4. **Modular design** makes it easy to add new agents

Next step: Build the **Report Agent** to generate beautiful reports from analytics data!